{
  "language": "Solidity",
  "sources": {
    "contracts/LiteraryNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\n/**\n * @title LiteraryNFT\n * @dev ERC-1155 token for gating access to literary works.\n * Each token ID represents a different book.\n * Multiple copies of each book can exist.\n *\n * Features:\n * - Owner and public mint (purchase)\n * - Max supply per book (0 = unlimited)\n * - Time-bounded sales (including free mints when price = 0)\n * - Metadata freeze flag\n * - Pausable minting/purchasing\n */\ncontract LiteraryNFT is ERC1155, Ownable, Pausable {\n    using Strings for uint256;\n\n    // Token IDs for each book\n    uint256 public constant THE_PROLOGUES   = 1;\n    uint256 public constant ASH_AND_STATIC  = 2;\n    uint256 public constant MIDNIGHT_LEDGER = 3;\n\n    // Base URI for metadata\n    string private _baseTokenURI;\n\n    // Metadata freeze flag\n    bool public metadataFrozen;\n\n    // Max supply per token ID (0 = unlimited)\n    mapping(uint256 => uint256) public maxSupply;\n\n    // Current minted supply per token ID\n    mapping(uint256 => uint256) public currentSupply;\n\n    /**\n     * @dev Pricing information for a book.\n     * basePrice: default price when there is no active sale.\n     * salePrice: price used during a sale window (can be 0 for free mint).\n     * saleStart / saleEnd: unix timestamps bounding the sale window.\n     */\n    struct BookPricing {\n        uint256 basePrice;\n        uint256 salePrice;\n        uint64 saleStart;\n        uint64 saleEnd;\n    }\n\n    mapping(uint256 => BookPricing) private _pricing;\n\n    event BookMinted(address indexed to, uint256 indexed tokenId, uint256 amount);\n    event BasePriceUpdated(uint256 indexed tokenId, uint256 newBasePrice);\n    event SaleUpdated(\n        uint256 indexed tokenId,\n        uint256 salePrice,\n        uint64 saleStart,\n        uint64 saleEnd\n    );\n    event BaseURIUpdated(string newBaseURI);\n    event MetadataFrozen();\n    event Withdrawn(address indexed to, uint256 amount);\n\n    constructor(string memory baseURI)\n        ERC1155(\"\")\n        Ownable(msg.sender)\n    {\n        _baseTokenURI = baseURI;\n\n        // Example initial pricing:\n        // Base price: 0.001 ETH (can be changed later by owner).\n        _pricing[THE_PROLOGUES].basePrice   = 0.001 ether;\n        _pricing[ASH_AND_STATIC].basePrice  = 0.001 ether;\n        _pricing[MIDNIGHT_LEDGER].basePrice = 0.001 ether;\n\n        // Max supply (0 = unlimited)\n        maxSupply[THE_PROLOGUES]   = 1000;\n        maxSupply[ASH_AND_STATIC]  = 1000;\n        maxSupply[MIDNIGHT_LEDGER] = 1000;\n    }\n\n    // --------- Views ---------\n\n    /**\n     * @dev Returns the metadata URI for a given token ID.\n     */\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        require(_isValidTokenId(tokenId), \"Invalid token ID\");\n        return string(abi.encodePacked(_baseTokenURI, tokenId.toString(), \".json\"));\n    }\n\n    /**\n     * @dev Returns the *current* effective price for a tokenId,\n     * taking into account any active sale window.\n     */\n    function getCurrentPrice(uint256 tokenId) public view returns (uint256) {\n        require(_isValidTokenId(tokenId), \"Invalid token ID\");\n\n        BookPricing memory p = _pricing[tokenId];\n\n        if (p.saleStart != 0 && p.saleEnd != 0) {\n            if (block.timestamp >= p.saleStart && block.timestamp <= p.saleEnd) {\n                // Active sale period (can be 0 for free mint)\n                return p.salePrice;\n            }\n        }\n\n        // Default to base price when there is no active sale\n        return p.basePrice;\n    }\n\n    /**\n     * @dev Helper to read pricing details for a book.\n     */\n    function getPricing(uint256 tokenId)\n        external\n        view\n        returns (BookPricing memory)\n    {\n        require(_isValidTokenId(tokenId), \"Invalid token ID\");\n        return _pricing[tokenId];\n    }\n\n    /**\n     * @dev Check if an address owns a specific book.\n     */\n    function ownsBook(address account, uint256 tokenId)\n        external\n        view\n        returns (bool)\n    {\n        require(_isValidTokenId(tokenId), \"Invalid token ID\");\n        return balanceOf(account, tokenId) > 0;\n    }\n\n    // --------- Minting ---------\n\n    /**\n     * @dev Mint a book NFT (owner only, for airdrops/giveaways).\n     */\n    function mint(\n        address to,\n        uint256 tokenId,\n        uint256 amount\n    ) external onlyOwner whenNotPaused {\n        require(_isValidTokenId(tokenId), \"Invalid token ID\");\n        require(amount > 0, \"Amount must be greater than 0\");\n\n        _enforceMaxSupply(tokenId, amount);\n\n        currentSupply[tokenId] += amount;\n        _mint(to, tokenId, amount, \"\");\n\n        emit BookMinted(to, tokenId, amount);\n    }\n\n    /**\n     * @dev Purchase a book NFT.\n     * - Respects max supply.\n     * - Uses the current price (base or sale).\n     * - Requires EXACT payment (no overpay).\n     */\n    function purchase(uint256 tokenId, uint256 amount)\n        external\n        payable\n        whenNotPaused\n    {\n        require(_isValidTokenId(tokenId), \"Invalid token ID\");\n        require(amount > 0, \"Amount must be greater than 0\");\n\n        uint256 unitPrice = getCurrentPrice(tokenId);\n        // price == 0 is allowed (free mint or free sale)\n        uint256 requiredValue = unitPrice * amount;\n        require(msg.value == requiredValue, \"Incorrect payment\");\n\n        _enforceMaxSupply(tokenId, amount);\n\n        currentSupply[tokenId] += amount;\n        _mint(msg.sender, tokenId, amount, \"\");\n\n        emit BookMinted(msg.sender, tokenId, amount);\n    }\n\n    // --------- Admin: pricing & sales ---------\n\n    /**\n     * @dev Set the base (non-sale) price for a book.\n     * This is the default price used when there is no active sale window.\n     */\n    function setBasePrice(uint256 tokenId, uint256 newBasePrice)\n        external\n        onlyOwner\n    {\n        require(_isValidTokenId(tokenId), \"Invalid token ID\");\n        _pricing[tokenId].basePrice = newBasePrice;\n\n        emit BasePriceUpdated(tokenId, newBasePrice);\n    }\n\n    /**\n     * @dev Configure a sale for a book.\n     * - `salePrice` can be 0 for free mint during the sale window.\n     * - Set `saleStart` and `saleEnd` as UNIX timestamps.\n     * - To disable a sale, set both to 0.\n     *\n     * Example: free mint for 24 hours:\n     *   setSale(tokenId, 0, uint64(block.timestamp), uint64(block.timestamp + 1 days));\n     */\n    function setSale(\n        uint256 tokenId,\n        uint256 salePrice,\n        uint64 saleStart,\n        uint64 saleEnd\n    ) external onlyOwner {\n        require(_isValidTokenId(tokenId), \"Invalid token ID\");\n        require(\n            saleStart == 0 && saleEnd == 0 || saleStart < saleEnd,\n            \"Invalid sale window\"\n        );\n\n        _pricing[tokenId].salePrice = salePrice;\n        _pricing[tokenId].saleStart = saleStart;\n        _pricing[tokenId].saleEnd = saleEnd;\n\n        emit SaleUpdated(tokenId, salePrice, saleStart, saleEnd);\n    }\n\n    // --------- Admin: supply & metadata ---------\n\n    /**\n     * @dev Update max supply for a book (owner only).\n     * Cannot be set below current supply.\n     */\n    function setMaxSupply(uint256 tokenId, uint256 newMaxSupply)\n        external\n        onlyOwner\n    {\n        require(_isValidTokenId(tokenId), \"Invalid token ID\");\n        require(\n            newMaxSupply == 0 || newMaxSupply >= currentSupply[tokenId],\n            \"Cannot set below current supply\"\n        );\n        maxSupply[tokenId] = newMaxSupply;\n    }\n\n    /**\n     * @dev Update base URI (owner only).\n     * Cannot be changed after metadata is frozen.\n     */\n    function setBaseURI(string memory newBaseURI) external onlyOwner {\n        require(!metadataFrozen, \"Metadata frozen\");\n        _baseTokenURI = newBaseURI;\n        emit BaseURIUpdated(newBaseURI);\n    }\n\n    /**\n     * @dev Freeze metadata permanently.\n     * After this, `setBaseURI` can no longer be called successfully.\n     */\n    function freezeMetadata() external onlyOwner {\n        require(!metadataFrozen, \"Already frozen\");\n        metadataFrozen = true;\n        emit MetadataFrozen();\n    }\n\n    // --------- Admin: pause / unpause ---------\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // --------- Admin: withdraw ---------\n\n    /**\n     * @dev Withdraw contract balance (owner only).\n     * Uses call instead of transfer for forward-compatibility.\n     */\n    function withdraw() external onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No balance to withdraw\");\n\n        address to = owner();\n        (bool success, ) = to.call{value: balance}(\"\");\n        require(success, \"Withdraw failed\");\n\n        emit Withdrawn(to, balance);\n    }\n\n    // --------- Internal helpers ---------\n\n    function _isValidTokenId(uint256 tokenId) internal pure returns (bool) {\n        return tokenId >= 1 && tokenId <= 3;\n    }\n\n    function _enforceMaxSupply(uint256 tokenId, uint256 amount) internal view {\n        uint256 max = maxSupply[tokenId];\n        if (max > 0) {\n            require(\n                currentSupply[tokenId] + amount <= max,\n                \"Max supply reached\"\n            );\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ]
      }
    }
  }
}
